#性能优化小结



##内存抖动

+ 原因：频繁的创建对象，并快速释放该对象，导致JVM频繁的GC；
+ 现象：AS的Monitor观察内存，明显的锯齿状，频繁的涨跌；通过Allocation Tracker 查看短时间内，同一个栈不断进出的相同对象。
+ 分析：
	+ for循环中分配对象；
	+ 自定义onDraw中创建对象；
+ 解决：尽量避免上述情况，若实在无法避免，可以考虑采用对象池模型来处理；

##内存泄漏

+ 概念：程序中不再使用的对象无法被GC识别，一直占用内存空间无法被释放掉。机器内存剩余空间减少，一方面需要申请更多的内存浪费资源，另一方面频繁的GC引发的性能问题；
+ 常见问题
	+ 自定义的View中set了listener等回调接口，没有主动释放；
	+ 自定义的Layout中set进了外部的某些view,没有主动释放；
	+ 初始化了第三方库，如volley,但是没有主动释放；
	+ 从activity中将actvity中的对象set进了包含的fragment，fragment的持有了该对象，fragment在destroy时没有主动释放；
	+ 非静态内部类导致的内存泄漏，如Hanlder，可以将内部类写成静态的，并使用弱引用的方式；
	+ IO操作，使用完后记得关闭stream之类;
	+ 自定义View中存在TypeArray，使用完之后没有关闭；
	+ 四大组件的context；
+ 查找办法
	+ AS的Memory Usage获取内存使用情况；
	+ AS获取内存快照分析内存，找到没有释放的对象，分析修改，验证；
+ 如何避免
	+ 减少内存使用
		+ 轻量级数据结构，如HashMap
		+ 减少Bitmap占用内存，缩放比例，修改解码格式；
		+ 使用更小的图片
	+ 内存重复使用
		+ 系统自带的资源，如color、layout\string等
		+ ListView,GridView等的itemView复用；
		+ Bitmap对象复用；
		+ StringBuilder字符串拼接；
	
+ 关键点：除了使用一些方法去检查修复，我们应该有个良好的**内存管理**意识，尽管JVM有自动的内存管理机制，但是由于我们书写了不合理的代码，到时无法GC。所以**主动防御**也很重要。

##