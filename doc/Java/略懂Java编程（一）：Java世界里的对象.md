###前言

正式进入章节，说明一下，我一般都会在每一篇博客的前言部分扯上几句闲话。程序猿最愁什么？我觉得就是最愁找对象。因为我们每天都与机器打交道，我们的眼里只有if、else，或者Exception。然而，回归了到真实的世界，总是那么的复杂，那么多的纠结。但是，回到虚拟的世界，我们可以随时new出我们想要的任何对象，这么多的对象，简直妃子三千，佳丽无数，我们真的懂她们吗？


### 1、初识OOP

OOP,既Object-oriented Programming，面向对象的程序设计。就这一句话，给Java赋予了生命，其实她和我们真实的世界离奇的相似。Java中的每个对象也会生老病死，会被人抛弃，被人替代，受人约束控制。当然也能继承祖宗家业，也可以白手成家。可以发展团队合作共赢，探讨出不同的商业模式，共同发家致富。这就是OOP,用人的思维来调配资源，做出计划，展开行动！

### 2、抽象过程

+ 我们将问题空间中的元素及其在解空间中的表示称为对象。
+ 每个对象看起来都有点像一台微型计算机——它具有状态，还具有操作，用户可以要求对象执行这些操作，

还记得你第一次在数学课上学的加减法老师是怎么讲的吗？比如1+4=？怎么计算。那个时候老师一般会说，一个篮子里边有1个鸡蛋，再往里边放4个鸡蛋，加起来一共是多少个？于是我们就1、2、3.....最后数到5，最后高高兴兴的举起手报告答案。可是到了后来，老师又教我们：1是被加数，4是加数，5是和。这个时候，每一个数字就有了自身的意义。如此我们就说有一道计算题，已知“被加数”是“1”，“加数”是4，求和。好了，我们可以这么认为，这道计算题是一个对象，1和4是问题空间里的元素，5是解空间里的表示。如果我们现在“被加数”的状态值是2，“加数"的状态值是4，执行加法运算这一个”行为“后（比如你背会了的加法口诀），得到的和就会变为6，不用去一个一个数了，就是这么神奇，对不对！

### 3、Java的五个特征

+ 万物皆为对象；
+ 程序是对象的集合，他们通过发送消息来告知彼此所要做的；
+ 每个对象都有自己的由其他的对象所构成的存储；
+ 每个对象都有拥有其类型；
+ 某一特定类型的所有对象都可以接收同样的消息；

### 4、每个对象都有一个接口

**每个对象都属于定义了特性和行为的某个特定的类**，比如我现在就属于被人们称为会敲代码写博客的“猿”类 中的千千万万个对象中的一个对象，当然我和人类一样，天生就会吃喝拉撒，所以我所说的**猿类** 继承了**人类**的基本特性，都有鼻子有眼的，每天也要吃饭睡觉。** 一个类一旦被创建，就可以随心所欲的创建类的任意一个对象**，自从android开发火了之后，千千万万当医生的、学历史的、搞机械的、挖石油的都纷纷转过来当码农，从此人生便得到新生，因为new出了一个全新的对象，我是一个程序猿。 **每个对象都只能满足某些请求，这些请求由对象的接口所定义，决定接口的便是类型。** 平时我们所认为的接口是写一个interface，然后一个类去实现这个interface接口，并实现接口所有的行为（有实现体的方法）。然而如果我们没有给一个类去implements一个interface的时候，我们可以通过这个类的对象去调用属于该类的方法。但是，这里更加深层次的理解应该是，这个类本身实现了一个隐含的interface，也就是说，如果我们的一个class中如果写很多个方法，但是方法里没有写具体做什么，这个时候这个class就和我们平时所写的interface具有一样的职能。**接口确定了对某一特定对象所能发出的请求，每一个可能的请求都有一个方法与之关联，当向对象发送请求的时候，与之关联的方法就会被调用。**举个网上的栗子，我们定义一个名为水杯的class，杯子的杯柄就是这个水杯本身隐含实现的一个接口，如果我们要喝水，我们需要和水杯通信，但是我们是通过杯柄拿起杯子喝水，此时这个杯柄就是这个水杯隐藏的interface。这里为何这么说？我查看了一下英文版的原著，其中:A type has a mothod associtated with each possible request,and **when you make a paticular request to an object,that method is called.**This process is usually summarized by saying that you "send a message"(make a request)to an object,and the object figures out what to do with that message(it excecutes code).当我们要执行一个class中的方法时，首先我们要拥有这个class的对象，然后我们用这个对象发起一个request，这个class所实现的接口（如果没有写implements，其实默认都有隐含实现了一个interface，就和我们所有的class都默认继承了object对象一样）,然后实现了的interface去call对应的method.

### 5、每个对象都提供服务

**如果我们可以将问题从表象中抽取出来，那么什么样的对象可以马上解决我们的问题呢？** 我们在工作中常常都会应用这种思维去解决我们的问题，我们要协调与之相关的人一起沟通协调完成工作任务。不同岗位的人就是不同的对象，比如我现在要报销一张发票。我可能不知道怎么报销，那么可能先要找文员组（一个class）中属于我们部门的文员（能够为我们部门服务的一个对象实体）咨询，然后得知要先找部长签字，找财务部报销组（class）的某某某（对象）办理，那么这个过程中我们就要找到相关的对象实体来完成。**将对象看做服务提供者还有一个附带的好处：他有助于提高软件的内聚性，高内聚是一个软件设计的基本质量要求之一。**如同我们一个公司，我们需要一个清晰的组织架构，分部门、分科室、分项目组、分具体的岗位，只有组织架构清晰，公司才能高效运转。也如同一辆汽车，不同的零部件都有设计合理，各自完成属于自身的职能，车子才跑的好。同样一个道理，我们在Java的世界里，我就属于一家公司的CEO，属于一辆汽车的设计者，我可以设计我需要的class，通过组合关系，完成一个高质量的程序开发。所有的对象都是我的程序的服务者！

哈哈,这一章是本书的难点，也是全书的重点，感觉需要读好几遍，细细的品味才能够真正的理解。如果有理解错的地方，希望批评指教。

### 6、被隐藏的具体实现

作为一个社会人，除了利用社会的资源，还要能够被这个社会所利用。那么其中就有两个非常重要的社会关系角色，生产者和消费者。作为生产者的一方，你肯定不是很想暴露自己的生产技术啊、技术专利啊等等。进行一些有必要的隐藏是非常重要的，主要有两个方面的好处。首先是自己内部的事情自己解决，别人无法干涉内政。也不用操心是否对外部有什么影响。然后就是不给别人看的东西别个看不见管不着。Java有三个关键字来设定边界，分别是public、private、protected。还有个默认的包访问权限。

### 7、复用和继承

**代码复用是面向对象程序设计语言所提供的的最了不起的有点之一**，为什么这么说呢？因为你要用一个类可以直接用创建的这个类的实例，另外这个类的对象也可以是另外一个对象的类的对象的成员之一。就好比你是你自己的同时，也是你妈妈的儿子，是你老板的小弟。这个时候，你就被复用了。在家要孝敬父母，在工作上要给老板做出业绩。当然，你也可以有你的小弟，你的财富，你的女朋友等等。这其中，有些是需要私有化的。比如你的财富等等。

人与人之间呢还有一种关系比较特殊，即使继承。在Java世界里也是一样的，一个子类继承了一个父类，这个时候子类就拥有的父类的可继承的一些能力。但是，如果到处都是用**继承**来复用类，就会把关系搞的很复杂。继承了一个父类，那么父类的接口直接继承给了子类。这样的话，子类就拥有的父类相同的类型和行为。但是了，作为年轻人嘛，总是要有点自己的个性的。比如，你继承了你爸的一家商店。到了你手里，你觉得装修太老气了，所以重新装修下。那么Java里面怎么搞呢，就是用override去覆盖父类那个方法。当然，如果你想在隔壁再开一家包子店，你也可以自己写个新的方法。翅膀硬了，你老子也管不着了。

### 8、伴随多态的可互换对象

我们有这么一种说法，见人说人话，见鬼说鬼话，人是善变的。那么Java同样也是如此，怎么做到的呢。对于那种非面向对象编程的编译器产生的函数调用的这种关系叫做**前期绑定**，可以理解为在编译期就把调用关系定死了不能变了，当程序运行时将要被执行的是代码的**绝对地址**。但是，对于面向对象编程的编译器就不是这么搞，在编译期知道的是一个泛化的对象。当代码运行调用的时候通过一小段特殊的代码替代为绝对地址的调用。这就是所谓的**后期绑定**，也称为动态绑定。这小段代码使用在对象中存储的信息来计算方法体的地址。这种动态绑定在Java语言中是默认的，但是在C++中需要用virtual关键字来实现。

### 9、容器

要完成一个程序的开发，只会new对象还是远远不够的，还有一点非常重要，就是存储对象。就像一家公司一样，除了会培养人才，还需要明白怎么留着人才。人才分很多种，一种是踏实肯干的，那么比较适合去执行一些既定任务。一些是想法多的，适合去做一些未知任务。那么稍微有点规模的公司，都会建立自己的人才库。那么在Java中也有自己的**容器**去装载这些对象，有Map、List、Set等，他们各自有各自的特点。比如Set不允许有重合的对象。每种容器都提供了不同的接口和外部行为，同样不同容器的操作效率也不是一样的。比如ArrayList随机访问get花销的时间是固定的，但是LinkedList不一样，要是开头还好，如果是队尾的元素就要遍历很多次。但是，如果是删除或者插入一个新的元素，LinkedList优势明显。这其中主要就是这些集合内部的数据结构以及实现操作的算法不同，具体这里不细说了。

### 10、泛型

前面已经提到了Java编程中的继承、多态是什么？也提到了容器可以做什么。看如下代码：

	public class ArrayList<E> extends AbstractList<E> implements Cloneable, Serializable, RandomAccess{}

我们暂且不看后面的代码，仅关注 ArrayList<E>，这里再"<"里面指定的类型便是集合的类型。如果是ArrayList<Object>,但是装载的都是ClassA的实例，这里可能并不存在问题，因为ClassA一定继承了Object的超类。但是这么做的话就会存在一个问题，容器中ClassA的实例都向上转型为Object类型的对象，那么当前状态下仅仅拥有Object的功能，如果要获得自己本身的功能，还需要**向下转型**变成自身原来的对象。就好比把你丢回到原始社会，一下子连个微信都发不了。怎么样才能够让自己拥有本身的能力不变呢，只需放到ArrayList<ClassA>就好了，如此就可以明白了泛型的作用了。也称为参数化类型机制。

### 11、对象的创建和生命周期

对于Java编程中，使用对象的两个关键的问题就是对象的生成和销毁方式。对象的存在是需要占用内存空间的，如果进行有效的管理对于一个程序而言显得很重要。这方面Java相对C++来说，做的更加智能。Java对象是通过new关键字构建的，并采用**动态分配方式存放在Java堆内存**里面。同时，Java的**垃圾回收**机制能够自动的发现堆内存空间上有哪些对象是**无用**的对象，然后进行回收清理。高级点的回收器还能对堆内存进行下调整。无用的生命只会占用有限的内存，有损于整个系统的效率。所以，要想生存，首先得有用。


### 12、异常

人一辈子，总免不了有些病痛异常，只要我们能够捕获去治疗，还不足以影响整个生命的运行。Java也是这样的，程序难免会出个bug，但是如果因为一个小问题而让整个系统崩溃无法运行就非常不友好了。Java的异常机制就是专为处理这种问题而存在，在发生错误的地点“抛出"异常，让专门的**异常处理器**来捕获，他就像和正常程序并行的另一台路径。**异常提供了一种错误状况进行可靠恢复的途径。**

### 13.并发

古时候神话里有有一种分身术，可以有几个化身同时做几件事情。其实这个从科学理论上来讲，如果你的移动速度足够快，不同场景下的切换的足够灵活，是可以达到这种效果的。在计算机世界里就是有这样的能力，通过程序的中断、切换，让表面上看起来同一时间在做好几件的事情。其实内部是东做一下，西做一下。我们把每件事情看成是在不同的**线程**下进行处理，线程是一种为单一处理器分配执行时间的手段。线程中有个处理的难点就是对于线程共享资源的处理。如果要处理好，必须要做到公私分明，对于共享的资源要商量着来，谁先谁后。


### 小结

Java的世界和我们的世界是一样的，唯一不同的是Java世界里的对象可以new出来，哈哈。面向对象编程，就是要把对象看成一个个活生生的实体，他有自己的属性，有自己的能力，以及有自己的亲戚朋友、社会关系等。不同的是，我就是上帝，我可以创造他，也可以毁灭他。最难的，就是如何去设计他，设计一个个体，设计每个个体之间的关系。只有设计的足够完美，程序的运行才能长治久安。























