#《EffectiveJava》学习笔记——并发

## 第66条：同步访问共享的可变数据

+ Synchronized可以保证在同一时刻，只有一个线程可以执行某一个方法，或者某一个代码块。
	+ 阻止一个线程看到对象处于不一致的状态之中（进不去）；
	+ 进入同步方法、块后看到同一个锁保护之前的所有修改效果（进去之后，看到的是同一个锁最后的修改）；


+ volatile修饰符不执行互斥访问，可以保证任何一个线程都将看到最近刚刚被写入的值；
	+ 安全性失败（safety failure）如果第二个线程在第一个线程读和写之间进行，会取到第一个线程修改写之前的旧值，导致错误；
		+ 建议使用 AtomicLong 等；
+ 原则：不共享可变数据，只共享不可变数据（每个读和写的操作都要执行同步），或者不共享（将可变数据限制在单个线程中）！

## 第67条：避免过度同步

+ 外来方法：在同步区域内部调用设计成要被覆盖的方法，或者以对象形势提供的方法；
+ 死锁：一个线程尝试去获取已经被锁定的对象，造成的程序阻塞；
	+ 在同步区域内部调用外来方法，容易造成死锁；
	+ 同一个线程再次重复拿锁，不会造成死锁，但是可能会有活性失败或者安全性失败；
+ 开放调用：在同步区域之外调用外来方法；
+ 应该尽量在同步区域内部做最少的工作；

##  第70条：线程安全性的文档化
+ 不可变的（immutable）：这个类的实例是不可变的，不需要外部进行同步处理，例如String,Long;
+ 无条件的线程安全（Unconditionally thread-safe):这个类的实例是可变的，但是内部有足够的同步处理，所以外部不需要进行同步。例如Random,ConcurrentHashMap;
	+ 使用私有锁对象来代替同步的方法；
+ 有条件的线程安全（Conditionally thread-safe):有些方法需要外部同步；
	+ 注明那个方法调用需要外部同步；
	+ 注明在执行这些序列的时候要获得哪把锁；
+ 非线程安全（not thread-safe):这个类的实例是可变的，外部并发使用必现要进行同步处理；

## 第71条：慎用延迟初始化

+ 对于实例域，使用双重检查模式(double-check idiom)；
+ 对于静态域，则使用 lazy initialization hodler class idiom;
+ 对于可以接受重复初始化的实例域，考虑使用单重检查模式（single-check idiom；