###并发的解决的问题：
+ 速度

+ 设计可管理性
###更快的执行

+ 并发可以提高在单处理器上的程序性能；

+ 实现并发最直接的方式是在操作系统级别使用**进程**；
    + 周期性的将CPU从一个进程切换到另一个进程；
    + 但是JAVA使用的并发系统会共享内存和I/O这样的资源，所以必须要协调不同驱动线程任务对这些资源的使用；

###线程机制
+ 机制：切分CPU时间，子线程都能分配到一定的时间执行任务；
+ 好处：CPU的个数可以任意扩展，与实际的线程代码运行无关；

### Thread
+ 让步：Thread.yield():在run()方法中调用Thread.yield()方法是对**线程调度器**的一种建议；
    + 线程调度器：Java线程机制的一部分，可以将CPU从一个线程转移给另一个线程；
    + **暗示**可以交给别的同样优先级的线程运行；
    + 可以看到任务换进换出的证据；
+ 执行：run():导出Runnable类的时候必须要有一个run()方法，这个方法不会产生任何内在的线程能力，要实现线程行为，必须显示的将一个任务附着到线程上；
+ 优先级
    + 设置优先级：在run()方法的开头处，Thread.currentThread().setPriority(int priority) ；
    + 实际原理：提高频率（实际优先分配时间片）；
    + 常用级别:MAX_PRIORITY,NORM_PRIORITY,MIN_PRIORITY;

+ 后台线程（daemon）
    + 定义：程序在运行的过程中在后台提供的一种通用服务的线程，这种线程并不能成为程序不可获取的部分；
    + 理解：如果非后台线程死了，那么后台线程也就会被杀死；
    + 设置：在启动（start())方法之前，调用threadSymbol(实现了runnable接口的一个线程实例).setDaemon(true);
    + 判断：isDaemon();

+ 加入一个线程（join)
    + 定义：如果一个线程在另一个线程t上调用t.join()，那么次线程将被挂起，知道目标线程t结束后才恢复；
    + 理解：有A和B两个线程，如果A线程在run()方法中，调用了B.join(),意思就A线程跑在路上的时候，把B线程的任务给加进来了，那么就只能等着B跑完然后A接着跑。但是呢,如果想强制中断也可以啊。直接掉B.interrupt()方法中断掉B线程，但是记得try-catch；
    + 


