##单一职责原则
一个类中应该是一组相关性很高的函数、数据的封装；
## 开闭原则
+ 定义：对于扩展是开放的，对于修改是封闭的；
+ 理解：意思就是可以任意的往外边扩展，但是不能对写好的修改，怎么达到这个要求呢？写接口。执行的方法写成接口，这样如果我们要扩展不同的实现，那就可以扩展新的实现了原来接口的类，然后丢进去就可以啦；
+ 实例：

        //执行体
        class A {
            // H:相当于任务的执行者
            private void doA( H h){
                h.doMyTask();//此处调用接口的方法，达到 闭 的效果,只管我要干啥，具体怎么干可以不管
            }
        }
        ---------------------------
        // 接口
        interface H{
            void doMyTask();
        }
        ---------------------------
        //任务执行者实现体
        class B implements H{
            void doMyTask(){
                sys.out("干B的活");
            }
        }

        class C implements H{
             void doMyTask(){
                 sys.out("干C的活");
             }
        }

        //操作者
        class K {
            A a =new A();
            a.doA(new B);
            a.doA(new C);
            a.doA(new H(){
                doMyTask(){
                     sys.out("干随时扩展自定义的活");
                }
            });

        }
+实例分析：
由上述我们可以分析得出，如果我是老K,我现在要让A干一件活，现在我知道要他干什么活，可以写死在A的doA()方法里边，但是如果有一天这个活有了不同的要求，那么我同样还是找A来干活，但是干什么活，通过接口的不同实现来定义；


##里氏替换原则 LSP
+ 定义：所有应用其基类的地方，必须都能透明的使用其子类的对象；
+ 核心原理：抽象、继承、多态
+ 理解：当我要一个人干一种活的时候，发现有一类人都要干这种活，比如吃饭。那么，我就可以把这一类人抽象出来，同样干“吃饭”这种活，不过很明显，每个人都会有每个人的吃放。所以吃饭这个活也是抽象的，继承的实现体具体去干自己的活。当然，加入我是食堂的，我喊一声可以吃放了。然后不同的人（实现体）就跑进食堂，纷纷吃自己的饭啦！
+ 实例：

       //食堂
       class ShiTang{
            void ganHuo(Person p){
                p.chiFan();
            }
       }
       //抽象
       abstarct class Person{
            public abstarct foid chiFan();
            public void shuiJiao(){
                //do ....
            }
       }
       //小明
       class xiaoMing extends Person{
            public void chiFan(){
                 sys.out("小明吃饭");
            }
       }
       //小兵
       class xiaoBing extends Person{
            public void chiFan(){
                 sys.out("小兵吃饭");
            }
       }

+ 分析：由Person类可以知道，我们把一类人抽象到父类，若果某一件活，不同子类有不同的干法，就发方法抽象出来，子类继承再具体实现它。真正要这一类人干活的时候，直接调父类。这样，如果传入的是子类，也同样适用，并且还能实现各干各的活；

## 依赖倒置原则 DIP
+ 定义：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的；
+ 理解：假如我现在需要租个房子，然后我把身边的朋友叫过来，说给我帮忙找个房子。然后朋友们就去找了。还有一种方案，我可以打个电话给中介，让中介给我找。这样的优势就是，我和真正去找房子的人没有直接的联系。如果朋友临时有事，可能就不能帮忙给我找了。但是，中介就不会发生这种情况；所以，当我们要做一件事的时候，并不需要把做事的人拉进来，而只需要下订单，把事情外包给专门做这种事情的人去做，具体是谁就不要管那么多；这样，可以随时更换外包公司,而不影响自身业务；
+ 实例：

        //我
        class Me{
           Zu zu ;
            // 我找个中介
            void setZu(Zu zu){
                this.zu=zu;
            }
            void zuFangZi(){
                zu.zuFang();//我找中介给我租房子
            }
        }
        //租房这件事
        interface Zu{
            void zuFang();
        }
        //中介 专干租房的事
        class ZhongJie implements Zu{
            void zuFang(){
              sys.out("中介租房");
            }
        }
        
+ 分析：有上述示例可以发现，我 和 中介 没有了直接的关联，但是照样把事情干了。如果这个中介倒闭了，我只要去换一家同样嫩帮我租房子的中介set进来就可以啦！