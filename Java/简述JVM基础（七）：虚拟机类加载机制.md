# 运行期类加载

我们一定心里有个疑问，我们那个多态是怎么回事？我们指定的一个接口，却可以等到运行时可以对应于不同的实现类。这是因为，Java有个特性就是依赖运行期动态加载和动态连接，这样实现了Java可以动态进行扩展。我们甚至可以从网络或者其他的地方加载一个二进制流作为程序的一部分。所以，我们通过编译器将我们写的Java文件代码编译成Class文件，程序跑起来的时候通过加载器。


# 加载过程

+ 加载
	+ 三件大事
		+ 1、通过类的全限定名来定义这个类的二进制流
		+ 2、将字节流代表的静态存储结构变成方法区的运行时数据结构
		+ 3、在方法去生成一个java.lang.Class对象，作为方法区数据的访问入口
	+ 自定义类加载器：重写loadClass（）方法
	+ 一个区别：数组类本身不通过类加载器创建，而是有虚拟机直接创建，但是数组的元素还是需要类加载器创建的；
	+ 
+ 连接
	+ 验证
		+ 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，避免导致系统奔溃
		+ 验证类型
			+ 文件格式验证：保证输入的字节流能够正确的解析并存储于方法区之内，格式上符合Java类型信息；
			+ 元数据验证：对元数据信息进行语义上的校验
			+ 字节码验证：通过数据流和控制流分析，确定程序语义是合法的，保证方法运行时不会危害虚拟机；
			+ 符号引用验证：验证类是否找到到（NoSuchMothodError），访问性是否正常等等，保证解析动作能正常运行；

		+ 验证是重要但不是必须的，对于反复验证呢过的Class可以考虑使用-Xverify:none参数来关闭大部分的类验证措施；
	+ 准备：为类变量分配内存并设置初始值（如int为0）。
	+ 解析：
		+ 可以放在初始化之后进行，比如需要动态加载的情况下
		+ 将常量池中的符号引用替换为直接引用的过程
			+ 符合引用：一组符号来描述所引用目标，与虚拟机内存布局无关；
			+ 直接引用：直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。和内存布局有关，目标已经在内存中；
		+ invokedynamic：动态调用点限定符，程序实际运行到这条指令的时候，解析动作才能进行；
		+ 解析种类
			+ 类或接口的解析
			+ 字段解析
			+ 类方法解析
			+ 接口方法解析
+ 初始化
	+ 必须要立即进行初始化的情况如下(主动引用)：
		+ new（实例化对象）、getstatic、putstatic（读取或者设置静态字段）、invokestatic（调用类静态方法）这4个字节码指令
		+ java.lang.reflect包的方法反射调用，类若没有初始化必须先进行初始化
		+ 初始化一个类，父类没有初始化，必须先初始化父类（但是接口不用，只有用到父接口时，才会初始化）
		+ main方法的类
		+ REF_ getStatic、REF_ putStatic、REF_ invokeStatic
	+ 被动引用
		+ 子类引用父类的静态字段，只初始化父类，而不会触发初始化子类
		+ 通过数组定义来引用类，不会触发此类的初始化
		+ 常量在编译阶段会存入到调用类的常量池中，本质上没有直接应用调用到定义了常量的类，因此定义了常量的这个类不会触发初始化
	+ <cinit>()方法：编译器自动收集类中的类变量的赋值动作和static代码块中的程序语句，并且能自动触发父类的<cinit>（）方法先进行初始化。遇到多线程并发的时候，会自动加锁，其他的线程会被阻塞。直到<cinit>执行完毕
+ 使用
+ 卸载

# 类加载器

+ 对于任何一个类，都需要和这个类的加载器与这个类共同确定在Java虚拟机中的唯一性，这里说的唯一性指的是“相等”,也就是我们平时说的Class对象的equals（）、isAssiganableFrom()、isInstance()方法的返回结果；

+ 双亲委派模型

当一个类的加载器收到了加载请求，不会自己先动手，而是委派给这个类的父类进行加载，如果找不到加载不了就反馈回来自己加载。这样的话，让Java的类一出生就有了很好的层次父子关系。当然也有一些手段去破坏这种关系而获得某种效果。