# 

# write Once ,Run AnyWhere

+ 统一的程序存储格式：不同平台的虚拟机于所有平台都统一使用程序存储格式——字节码（ByteCode);
+ Java虚拟机不关心Class文件的来源，而只和“Class文件"这种二进制文件格式关联，也就是说Java虚拟机只认识“Class"文件；
+ Java编译器可以把Java程序代码编译成虚拟机所需要的Class文件；

# Class文件结构
 
Class文件是以8个字节为单位的二进制流，紧凑排列，中间没有空隙；如果想查看一个Class文件除了通过winHex编译器看到字节码，也可以通过javap -verbose xxx.Class 输出字节码内容,这样看起来比较直观。

### 基本类型

+ 无符号数：
	+ 定义：基本的数据类型，u1、u8表示1个字节，8个字节。
	+ 使用：可以用来描述数字、索引、引用，utf-8格式的字符串；

+ 表：
	+ 定义：多个无符号数和其他表组成的复合数据类型；通常以“_info” 结尾。
	+ 使用：描述有层次关系的复合结构数据；


### 魔数与版本

+ 魔数：每个Class文件的头4个字节，唯一作用就是确定这个文件是否能被一个虚拟机接受的Class文件；
+ 次版本号：紧接着魔数后面的第5和第6个字节；
+ 主版本号：第7和第8个字节代表主版本号，比如说50对应的就是JDK1.6.
+ 可以使用十六进制编译器WinHex打开一个Class文件瞅瞅；

### 常量池

版本号之后紧跟的就是常量池入口，可以理解为Class文件之中的资源仓库；

+ 常量池容量计数器：u2类型，代表本Class文件有N-1个常量（因为是从1开始技术的）；
	+ 0项常量：不引用任何一个常量池项目
+ 常量池放置的内容每一项都是一个表，主要分两类
	+ 字面量：文本字符串、final常量值等；
	+ 符号引用
		+ 类和接口的全限定名
		+ 字段的名称和描述符
		+ 方法的名称和描述符

+ length：
	+ 定义：UTF-8编码的字符串长度是多少个字节；
	+ 65535限制：Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量的length为u2类型，最大为65535.如果某个变量或者方法名超过了64K，那么这个length容不下了，当然也就无法编译了。


### 访问标志(access_flags)

常量池之后紧跟的就是访问标志。主要包括了这个Class是类or接口，是不是public,是不是abstract类型，是不是final类型。

### 类索引、父类索引于接口类集合

+ java.lang.Object类索引为0；
+ 类的索引其实就是描述了这个Class的extends和implements的关系；

### 字段表集合(field_info)

+ 用于描述定义的变量，依次包括了访问标志（access_flags)、名称索引（name_index)、描述索引（descriptor_index)、属性表集合（attributes)。
+ 描述的信息如下：
	+ 作用域：public、private、protect
	+ 实例or类变量：static
	+ 可变性：final
	+ 并发可见性：volatile
	+ 是否可序列化：transient
	+ 字段数据类型：基本类型、对象、数组等
	+ 字段名称；

+ 字段表集合原则
	+ 1、不会列出超类or父类或者父接口继承而来的字段；
	+ 2、有可能列出原本Java代码中不存在的字段（内部类会自动添加指向外部类实例的字段，才能引用到外部类）；
	+ 3、Java语言中字段是无法重载的；

### 方法表集合

和字段表集合差不多，方法表集合用来描述Clas文件中的方法，但是访问标志和属性表集合和字段表集合有所区别；

+ 访问标志：
	+ volatile、transient关键字不可以修饰方法，方法表中少了这两种标志；
	+ synchronized、native、strictfp和abstract可以修复方法，故方法表增加了这些对应的标志；
+ Code属性：
	+ 方法体中的代码放在了“Code”属性里面了；

+ 方法表集合原则
	+ 方法没有重写（Override)，父类的信息不会写到子类的方法表中；
	+ 编译器有可能自动添加一些方法，典型的如类构造器的“<clinit>”、方法&实例构造器的“<init>“方法；
	+ 重载（Overload)一个方法，需要添加一个特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合；

### 属性表集合（attribute_info)

上述那些表需要携带自己的某些属性，来描述自己的特殊环境信息，比如InnderClasses、LineNumberTable、Code之类的；


+ Code
	+ max_stack:操作栈深度最大值，JVM运行时根据这个值来分配栈帧（Stack Frame)中的操作栈深度；
	+ max_locals:代表了局部变量表所需要的存储空间。
		+ Slot: