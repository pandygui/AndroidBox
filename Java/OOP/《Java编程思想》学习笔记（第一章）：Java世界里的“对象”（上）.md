###前言

正式进入章节，说明一下，我一般都会在每一篇博客的前言部分扯上几句闲话。程序猿最愁什么？我觉得就是最愁找对象。因为我们每天都与机器打交道，我们的眼里只有if、else，或者Exception。然而，回归了到真实的世界，总是那么的复杂，那么多的纠结。但是，回到虚拟的世界，我们可以随时new出我们想要的任何对象，这么多的对象，简直妃子三千，佳丽无数，我们真的懂她们吗？


###初识OOP
OOP,既Object-oriented Programming，面向对象的程序设计。就这一句话，给Java赋予了生命，其实她和我们真实的世界离奇的相似。Java中的每个对象也会生老病死，会被人抛弃，被人替代，受人约束控制。当然也能继承祖宗家业，也可以白手成家。可以发展团队合作共赢，探讨出不同的商业模式，共同发家致富。这就是OOP,用人的思维来调配资源，做出计划，展开行动！

###1.1抽象过程

+ 我们将问题空间中的元素及其在解空间中的表示称为对象。
+ 每个对象看起来都有点像一台微型计算机——它具有状态，还具有操作，用户可以要求对象执行这些操作，

还记得你第一次在数学课上学的加减法老师是怎么讲的吗？比如1+4=？怎么计算。那个时候老师一般会说，一个篮子里边有1个鸡蛋，再往里边放4个鸡蛋，加起来一共是多少个？于是我们就1、2、3.....最后数到5，最后高高兴兴的举起手报告答案。可是到了后来，老师又教我们：1是被加数，4是加数，5是和。这个时候，每一个数字就有了自身的意义。如此我们就说有一道计算题，已知“被加数”是“1”，“加数”是4，求和。好了，我们可以这么认为，这道计算题是一个对象，1和4是问题空间里的元素，5是解空间里的表示。如果我们现在“被加数”的状态值是2，“加数"的状态值是4，执行加法运算这一个”行为“后（比如你背会了的加法口诀），得到的和就会变为6，不用去一个一个数了，就是这么神奇，对不对！

#####Java的五个特征

+ 万物皆为对象；
+ 程序是对象的集合，他们通过发送消息来告知彼此所要做的；
+ 每个对象都有自己的由其他的对象所构成的存储；
+ 每个对象都有拥有其类型；
+ 某一特定类型的所有对象都可以接收同样的消息；

###1.2每个对象都有一个接口

**每个对象都属于定义了特性和行为的某个特定的类**，比如我现在就属于被人们称为会敲代码写博客的“猿”类 中的千千万万个对象中的一个对象，当然我和人类一样，天生就会吃喝拉撒，所以我所说的**猿类** 继承了**人类**的基本特性，都有鼻子有眼的，每天也要吃饭睡觉。** 一个类一旦被创建，就可以随心所欲的创建类的任意一个对象**，自从android开发火了之后，千千万万当医生的、学历史的、搞机械的、挖石油的都纷纷转过来当码农，从此人生便得到新生，因为new出了一个全新的对象，我是一个程序猿。 **每个对象都只能满足某些请求，这些请求由对象的接口所定义，决定接口的便是类型。** 平时我们所认为的接口是写一个interface，然后一个类去实现这个interface接口，并实现接口所有的行为（有实现体的方法）。然而如果我们没有给一个类去implements一个interface的时候，我们可以通过这个类的对象去调用属于该类的方法。但是，这里更加深层次的理解应该是，这个类本身实现了一个隐含的interface，也就是说，如果我们的一个class中如果写很多个方法，但是方法里没有写具体做什么，这个时候这个class就和我们平时所写的interface具有一样的职能。**接口确定了对某一特定对象所能发出的请求，每一个可能的请求都有一个方法与之关联，当向对象发送请求的时候，与之关联的方法就会被调用。**举个网上的栗子，我们定义一个名为水杯的class，杯子的杯柄就是这个水杯本身隐含实现的一个接口，如果我们要喝水，我们需要和水杯通信，但是我们是通过杯柄拿起杯子喝水，此时这个杯柄就是这个水杯隐藏的interface。这里为何这么说？我查看了一下英文版的原著，其中:A type has a mothod associtated with each possible request,and **when you make a paticular request to an object,that method is called.**This process is usually summarized by saying that you "send a message"(make a request)to an object,and the object figures out what to do with that message(it excecutes code).当我们要执行一个class中的方法时，首先我们要拥有这个class的对象，然后我们用这个对象发起一个request，这个class所实现的接口（如果没有写implements，其实默认都有隐含实现了一个interface，就和我们所有的class都默认继承了object对象一样）,然后实现了的interface去call对应的method.

###1.3每个对象都提供服务

**如果我们可以将问题从表象中抽取出来，那么什么样的对象可以马上解决我们的问题呢？** 我们在工作中常常都会应用这种思维去解决我们的问题，我们要协调与之相关的人一起沟通协调完成工作任务。不同岗位的人就是不同的对象，比如我现在要报销一张发票。我可能不知道怎么报销，那么可能先要找文员组（一个class）中属于我们部门的文员（能够为我们部门服务的一个对象实体）咨询，然后得知要先找部长签字，找财务部报销组（class）的某某某（对象）办理，那么这个过程中我们就要找到相关的对象实体来完成。**将对象看做服务提供者还有一个附带的好处：他有助于提高软件的内聚性，高内聚是一个软件设计的基本质量要求之一。**如同我们一个公司，我们需要一个清晰的组织架构，分部门、分科室、分项目组、分具体的岗位，只有组织架构清晰，公司才能高效运转。也如同一辆汽车，不同的零部件都有设计合理，各自完成属于自身的职能，车子才跑的好。同样一个道理，我们在Java的世界里，我就属于一家公司的CEO，属于一辆汽车的设计者，我可以设计我需要的class，通过组合关系，完成一个高质量的程序开发。所有的对象都是我的程序的服务者！

哈哈,这一章是本书的难点，也是全书的重点，感觉需要读好几遍，细细的品味才能够真正的理解。如果有理解错的地方，希望批评指教。